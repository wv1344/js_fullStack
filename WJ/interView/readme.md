
# 对 es6 的理解
  es6 相对于 es5  ECMAScript 的第六次修订 ES2015 随着 Babel webpack 构建工具的成熟，
  es6 已成为 js 编程的事实标准，
  我认为 es6 比 es5 更加简洁，提高了开发效率，让 js 代码更优雅 

  - 新增的特性
    let 变量声明和 const 常量声明，具有 var 没有的块级作用域，比如循环事件监听时，闭包就不需要了，让代码更好理解。
    var 有变量提升的能力，let const 不会到顶级对象，使用的变量或常量一下要升级
    const 声明一定要有值

  - 箭头函数
    简化了函数的表达形式
    1. 不用 function 关键字 () => { } 
    2. 如果只有一个参数，() 也可以省略
    3. 如果代码直接时返回值，{} 也可以省略 右侧的代码就是返回值
    4. 有效的规避了 this 丢失的问题 指向上一级

  - 模板字符串
    增强版的字符串，用 ``  去括号，他的多行表达方式，特别是个 react jsx template 的书写
    DOM 或 html 模板的构建 更加优雅

  - 解构
    可解 spread 可合，reset 从对象或数组中提取值，对变量进行赋值，提高开发效率

  - for of 循环
    for 计步，数组友好，但是对象， Set Map 类数组 以及字符串都可以遍历
  
  - SET es6 新增的数据结构，类似数组，唯一的，没有重复的值

  - import export es6的模块化，es6 原生支持的 module 将 js 代码分割成不同的小块独立开发，
    一个文件一个类，一个独立的模块，比如说 utils api 

  - ...展开运算符

  - 终于支持原生的 class 关键字了，让 js 有了传统面向对象的写法，extends 不过它只是语法糖，
    底层还是基于原型的面向对象

  - Promise 为 js 提供了异步解决方案，规避了回调地狱(then) 代码的书写和执行是一样的

  - 更棒的异步解决方案 es7 的 async await
    Koa 就是基于 async await 快速取代了 express 的江湖地位
  
  - vue react 响应式编程依赖的 proxy defindProperty 监听对象的改变，做一些事情

  - es6 提供了新的数据类型，Symbol


# q1. js全局执行上下文为我们创建了两个东西，一个是全局对象，一个是this关键字
  new方法的实现原理
    1. 创建一个空对象，构造函数的this指向这个空对象
    2. 这个新对象被执行[原型]连接
    3. 执行构造函数  将属性或者方法添加到this引用的对象上
    4. 如果构造函数中没有返回其他对象，那么返回this，即创建的新对象。否则，返回构造函数返回的对象

    ①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的。但是由于JS中函数也是一种对象，所以函数也拥有__proto__和constructor属性

# q2. call bind apply
  1. b.call(a)  就相当于把 b 里面的作用域强行指向到 a 里面去
     第一个参数一定是 this 作用域要去到的地方
     第二三四....个参数是该作用域里用到的值
  2. b.apply(a)...用到的值，但是需要用数组类型
  3. b.call || b.apply() 此时 this 的作用域会指向 window
  4. c = b.bind(a) 
     c();
     bind 方法返回的是一个修改过的函数，所以该用函数该有的姿态去调用
     bind 方法接收的参数是按照形参的顺序进行的

# q3. 浅拷贝 深拷贝
  1. 数组解构：
    let [x,y] = [1,2]
    //  x = 1,
    //  y = 2
  2. let {foo,bar} = {foo:'aaa',bar:'bbb'}
    // foo = 'aaa'
    // bar = 'bbb'
    另:(允许给赋值的变量重命名)
    let {foo:baz} = {foo:'abc'}
    // baz = 'abc'
    解析：
      1. foo是用来做匹配的，用来去结构对象里面寻找值的
      2. baz 才是变量名，baz = 'abc'
  3. 浅拷贝
    浅拷贝只是第一层属性进行拷贝，当第一层的属性为基本数据类型时，新对象和原对象互不影响，
    但是如果第一层的属性值是 # 复杂数据类型 # 那么新对象和原对象的属性值其指向的是同一块内存地址
  4. 深拷贝
    深拷贝是将对象及值复制过来，两个对象修改其中任意一个的值，另一个不会改变

# q4. 闭包
  闭包是指有权限访问 另一个函数作用域中 的变量 的函数
  1. 能够访问函数定义时所在的词法作用域（阻止其被回收）
  2. 私有化变量
  3. 模拟块级作用域

# q5. 数组去重
  1. Set方法
  2. indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。
  3. includes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。
  4. map()
  5. reduce()

# q6. 防抖节流函数原理
  设定定时器，若干秒后可以再次点击

# q7. __proto__ 和 prototype 关联    typeof instanceof
  typeof 只能判断基本数据类型 instanceof 只能判断复杂数据类型
  __proto__ 是每一个实例都有的属性，可以访问 prototype 属性
  [prototype] 属性，实例的__proto__与其构造函数的prototype指向的是同一个对象
  // 准确判断数据类型
  Object.prototype.toString.call()

# q8. ['1','2','3'].map(parseInt)

# q9. 事件委托

# q10. 一个页面从输入 url 到页面渲染完成 中间发生了什么    双向数据绑定实现

  1. 浏览器的地址栏输入URL并按下回车。
  2. 浏览器查找当前URL是否存在缓存，并比较缓存是否过期。
  3. DNS解析URL对应的IP。
  4. 根据IP建立TCP连接（三次握手）。
  5. HTTP发起请求。
  6. 服务器处理请求，浏览器接收HTTP响应。
  7. 渲染页面，构建DOM树。
  8. 关闭TCP连接（四次挥手）。

# index.js 腾讯面试

